// Code generated by "enumer -sql=false -linecomment -json -type=OperationMode,PumpState,BlowerMode,LightsMode,PowerSaveMode,HeatPumpMode,LockMode,SleepTimerState -output=status_strings.go status.go"; DO NOT EDIT.

package spanet

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _OperationModeName = "NORMECONAWAYWEEK"

var _OperationModeIndex = [...]uint8{0, 4, 8, 12, 16}

const _OperationModeLowerName = "normeconawayweek"

func (i OperationMode) String() string {
	if i >= OperationMode(len(_OperationModeIndex)-1) {
		return fmt.Sprintf("OperationMode(%d)", i)
	}
	return _OperationModeName[_OperationModeIndex[i]:_OperationModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OperationModeNoOp() {
	var x [1]struct{}
	_ = x[OperationModeNormal-(0)]
	_ = x[OperationModeEconomy-(1)]
	_ = x[OperationModeAway-(2)]
	_ = x[OperationModeWeekdays-(3)]
}

var _OperationModeValues = []OperationMode{OperationModeNormal, OperationModeEconomy, OperationModeAway, OperationModeWeekdays}

var _OperationModeNameToValueMap = map[string]OperationMode{
	_OperationModeName[0:4]:        OperationModeNormal,
	_OperationModeLowerName[0:4]:   OperationModeNormal,
	_OperationModeName[4:8]:        OperationModeEconomy,
	_OperationModeLowerName[4:8]:   OperationModeEconomy,
	_OperationModeName[8:12]:       OperationModeAway,
	_OperationModeLowerName[8:12]:  OperationModeAway,
	_OperationModeName[12:16]:      OperationModeWeekdays,
	_OperationModeLowerName[12:16]: OperationModeWeekdays,
}

var _OperationModeNames = []string{
	_OperationModeName[0:4],
	_OperationModeName[4:8],
	_OperationModeName[8:12],
	_OperationModeName[12:16],
}

// OperationModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OperationModeString(s string) (OperationMode, error) {
	if val, ok := _OperationModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OperationModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to OperationMode values", s)
}

// OperationModeValues returns all values of the enum
func OperationModeValues() []OperationMode {
	return _OperationModeValues
}

// OperationModeStrings returns a slice of all String values of the enum
func OperationModeStrings() []string {
	strs := make([]string, len(_OperationModeNames))
	copy(strs, _OperationModeNames)
	return strs
}

// IsAOperationMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i OperationMode) IsAOperationMode() bool {
	for _, v := range _OperationModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for OperationMode
func (i OperationMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for OperationMode
func (i *OperationMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("OperationMode should be a string, got %s", data)
	}

	var err error
	*i, err = OperationModeString(s)
	return err
}

const (
	_PumpStateName_0      = "OffOn"
	_PumpStateLowerName_0 = "offon"
	_PumpStateName_1      = "Auto"
	_PumpStateLowerName_1 = "auto"
)

var (
	_PumpStateIndex_0 = [...]uint8{0, 3, 5}
	_PumpStateIndex_1 = [...]uint8{0, 4}
)

func (i PumpState) String() string {
	switch {
	case 0 <= i && i <= 1:
		return _PumpStateName_0[_PumpStateIndex_0[i]:_PumpStateIndex_0[i+1]]
	case i == 4:
		return _PumpStateName_1
	default:
		return fmt.Sprintf("PumpState(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _PumpStateNoOp() {
	var x [1]struct{}
	_ = x[PumpStateOff-(0)]
	_ = x[PumpStateOn-(1)]
	_ = x[PumpStateAuto-(4)]
}

var _PumpStateValues = []PumpState{PumpStateOff, PumpStateOn, PumpStateAuto}

var _PumpStateNameToValueMap = map[string]PumpState{
	_PumpStateName_0[0:3]:      PumpStateOff,
	_PumpStateLowerName_0[0:3]: PumpStateOff,
	_PumpStateName_0[3:5]:      PumpStateOn,
	_PumpStateLowerName_0[3:5]: PumpStateOn,
	_PumpStateName_1[0:4]:      PumpStateAuto,
	_PumpStateLowerName_1[0:4]: PumpStateAuto,
}

var _PumpStateNames = []string{
	_PumpStateName_0[0:3],
	_PumpStateName_0[3:5],
	_PumpStateName_1[0:4],
}

// PumpStateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func PumpStateString(s string) (PumpState, error) {
	if val, ok := _PumpStateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _PumpStateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to PumpState values", s)
}

// PumpStateValues returns all values of the enum
func PumpStateValues() []PumpState {
	return _PumpStateValues
}

// PumpStateStrings returns a slice of all String values of the enum
func PumpStateStrings() []string {
	strs := make([]string, len(_PumpStateNames))
	copy(strs, _PumpStateNames)
	return strs
}

// IsAPumpState returns "true" if the value is listed in the enum definition. "false" otherwise
func (i PumpState) IsAPumpState() bool {
	for _, v := range _PumpStateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for PumpState
func (i PumpState) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PumpState
func (i *PumpState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("PumpState should be a string, got %s", data)
	}

	var err error
	*i, err = PumpStateString(s)
	return err
}

const _BlowerModeName = "VariableRampOff"

var _BlowerModeIndex = [...]uint8{0, 8, 12, 15}

const _BlowerModeLowerName = "variablerampoff"

func (i BlowerMode) String() string {
	if i >= BlowerMode(len(_BlowerModeIndex)-1) {
		return fmt.Sprintf("BlowerMode(%d)", i)
	}
	return _BlowerModeName[_BlowerModeIndex[i]:_BlowerModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _BlowerModeNoOp() {
	var x [1]struct{}
	_ = x[BlowerModeVariable-(0)]
	_ = x[BlowerModeRamp-(1)]
	_ = x[BlowerModeOff-(2)]
}

var _BlowerModeValues = []BlowerMode{BlowerModeVariable, BlowerModeRamp, BlowerModeOff}

var _BlowerModeNameToValueMap = map[string]BlowerMode{
	_BlowerModeName[0:8]:        BlowerModeVariable,
	_BlowerModeLowerName[0:8]:   BlowerModeVariable,
	_BlowerModeName[8:12]:       BlowerModeRamp,
	_BlowerModeLowerName[8:12]:  BlowerModeRamp,
	_BlowerModeName[12:15]:      BlowerModeOff,
	_BlowerModeLowerName[12:15]: BlowerModeOff,
}

var _BlowerModeNames = []string{
	_BlowerModeName[0:8],
	_BlowerModeName[8:12],
	_BlowerModeName[12:15],
}

// BlowerModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func BlowerModeString(s string) (BlowerMode, error) {
	if val, ok := _BlowerModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _BlowerModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to BlowerMode values", s)
}

// BlowerModeValues returns all values of the enum
func BlowerModeValues() []BlowerMode {
	return _BlowerModeValues
}

// BlowerModeStrings returns a slice of all String values of the enum
func BlowerModeStrings() []string {
	strs := make([]string, len(_BlowerModeNames))
	copy(strs, _BlowerModeNames)
	return strs
}

// IsABlowerMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i BlowerMode) IsABlowerMode() bool {
	for _, v := range _BlowerModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for BlowerMode
func (i BlowerMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for BlowerMode
func (i *BlowerMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("BlowerMode should be a string, got %s", data)
	}

	var err error
	*i, err = BlowerModeString(s)
	return err
}

const _LightsModeName = "WhiteColourStepFadeParty"

var _LightsModeIndex = [...]uint8{0, 5, 11, 15, 19, 24}

const _LightsModeLowerName = "whitecolourstepfadeparty"

func (i LightsMode) String() string {
	if i >= LightsMode(len(_LightsModeIndex)-1) {
		return fmt.Sprintf("LightsMode(%d)", i)
	}
	return _LightsModeName[_LightsModeIndex[i]:_LightsModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LightsModeNoOp() {
	var x [1]struct{}
	_ = x[LightsModeWhite-(0)]
	_ = x[LightsModeColour-(1)]
	_ = x[LightsModeStep-(2)]
	_ = x[LightsModeFade-(3)]
	_ = x[LightsModeParty-(4)]
}

var _LightsModeValues = []LightsMode{LightsModeWhite, LightsModeColour, LightsModeStep, LightsModeFade, LightsModeParty}

var _LightsModeNameToValueMap = map[string]LightsMode{
	_LightsModeName[0:5]:        LightsModeWhite,
	_LightsModeLowerName[0:5]:   LightsModeWhite,
	_LightsModeName[5:11]:       LightsModeColour,
	_LightsModeLowerName[5:11]:  LightsModeColour,
	_LightsModeName[11:15]:      LightsModeStep,
	_LightsModeLowerName[11:15]: LightsModeStep,
	_LightsModeName[15:19]:      LightsModeFade,
	_LightsModeLowerName[15:19]: LightsModeFade,
	_LightsModeName[19:24]:      LightsModeParty,
	_LightsModeLowerName[19:24]: LightsModeParty,
}

var _LightsModeNames = []string{
	_LightsModeName[0:5],
	_LightsModeName[5:11],
	_LightsModeName[11:15],
	_LightsModeName[15:19],
	_LightsModeName[19:24],
}

// LightsModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LightsModeString(s string) (LightsMode, error) {
	if val, ok := _LightsModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LightsModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LightsMode values", s)
}

// LightsModeValues returns all values of the enum
func LightsModeValues() []LightsMode {
	return _LightsModeValues
}

// LightsModeStrings returns a slice of all String values of the enum
func LightsModeStrings() []string {
	strs := make([]string, len(_LightsModeNames))
	copy(strs, _LightsModeNames)
	return strs
}

// IsALightsMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LightsMode) IsALightsMode() bool {
	for _, v := range _LightsModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LightsMode
func (i LightsMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LightsMode
func (i *LightsMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LightsMode should be a string, got %s", data)
	}

	var err error
	*i, err = LightsModeString(s)
	return err
}

const _PowerSaveModeName = "OffLowHigh"

var _PowerSaveModeIndex = [...]uint8{0, 3, 6, 10}

const _PowerSaveModeLowerName = "offlowhigh"

func (i PowerSaveMode) String() string {
	if i >= PowerSaveMode(len(_PowerSaveModeIndex)-1) {
		return fmt.Sprintf("PowerSaveMode(%d)", i)
	}
	return _PowerSaveModeName[_PowerSaveModeIndex[i]:_PowerSaveModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _PowerSaveModeNoOp() {
	var x [1]struct{}
	_ = x[PowerSaveModeOff-(0)]
	_ = x[PowerSaveModeLow-(1)]
	_ = x[PowerSaveModeHigh-(2)]
}

var _PowerSaveModeValues = []PowerSaveMode{PowerSaveModeOff, PowerSaveModeLow, PowerSaveModeHigh}

var _PowerSaveModeNameToValueMap = map[string]PowerSaveMode{
	_PowerSaveModeName[0:3]:       PowerSaveModeOff,
	_PowerSaveModeLowerName[0:3]:  PowerSaveModeOff,
	_PowerSaveModeName[3:6]:       PowerSaveModeLow,
	_PowerSaveModeLowerName[3:6]:  PowerSaveModeLow,
	_PowerSaveModeName[6:10]:      PowerSaveModeHigh,
	_PowerSaveModeLowerName[6:10]: PowerSaveModeHigh,
}

var _PowerSaveModeNames = []string{
	_PowerSaveModeName[0:3],
	_PowerSaveModeName[3:6],
	_PowerSaveModeName[6:10],
}

// PowerSaveModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func PowerSaveModeString(s string) (PowerSaveMode, error) {
	if val, ok := _PowerSaveModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _PowerSaveModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to PowerSaveMode values", s)
}

// PowerSaveModeValues returns all values of the enum
func PowerSaveModeValues() []PowerSaveMode {
	return _PowerSaveModeValues
}

// PowerSaveModeStrings returns a slice of all String values of the enum
func PowerSaveModeStrings() []string {
	strs := make([]string, len(_PowerSaveModeNames))
	copy(strs, _PowerSaveModeNames)
	return strs
}

// IsAPowerSaveMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i PowerSaveMode) IsAPowerSaveMode() bool {
	for _, v := range _PowerSaveModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for PowerSaveMode
func (i PowerSaveMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PowerSaveMode
func (i *PowerSaveMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("PowerSaveMode should be a string, got %s", data)
	}

	var err error
	*i, err = PowerSaveModeString(s)
	return err
}

const _HeatPumpModeName = "AutoHeatCoolDisable"

var _HeatPumpModeIndex = [...]uint8{0, 4, 8, 12, 19}

const _HeatPumpModeLowerName = "autoheatcooldisable"

func (i HeatPumpMode) String() string {
	if i >= HeatPumpMode(len(_HeatPumpModeIndex)-1) {
		return fmt.Sprintf("HeatPumpMode(%d)", i)
	}
	return _HeatPumpModeName[_HeatPumpModeIndex[i]:_HeatPumpModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _HeatPumpModeNoOp() {
	var x [1]struct{}
	_ = x[HeatPumpModeAuto-(0)]
	_ = x[HeatPumpModeHeat-(1)]
	_ = x[HeatPumpModeCool-(2)]
	_ = x[HeatPumpModeDisable-(3)]
}

var _HeatPumpModeValues = []HeatPumpMode{HeatPumpModeAuto, HeatPumpModeHeat, HeatPumpModeCool, HeatPumpModeDisable}

var _HeatPumpModeNameToValueMap = map[string]HeatPumpMode{
	_HeatPumpModeName[0:4]:        HeatPumpModeAuto,
	_HeatPumpModeLowerName[0:4]:   HeatPumpModeAuto,
	_HeatPumpModeName[4:8]:        HeatPumpModeHeat,
	_HeatPumpModeLowerName[4:8]:   HeatPumpModeHeat,
	_HeatPumpModeName[8:12]:       HeatPumpModeCool,
	_HeatPumpModeLowerName[8:12]:  HeatPumpModeCool,
	_HeatPumpModeName[12:19]:      HeatPumpModeDisable,
	_HeatPumpModeLowerName[12:19]: HeatPumpModeDisable,
}

var _HeatPumpModeNames = []string{
	_HeatPumpModeName[0:4],
	_HeatPumpModeName[4:8],
	_HeatPumpModeName[8:12],
	_HeatPumpModeName[12:19],
}

// HeatPumpModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func HeatPumpModeString(s string) (HeatPumpMode, error) {
	if val, ok := _HeatPumpModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _HeatPumpModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to HeatPumpMode values", s)
}

// HeatPumpModeValues returns all values of the enum
func HeatPumpModeValues() []HeatPumpMode {
	return _HeatPumpModeValues
}

// HeatPumpModeStrings returns a slice of all String values of the enum
func HeatPumpModeStrings() []string {
	strs := make([]string, len(_HeatPumpModeNames))
	copy(strs, _HeatPumpModeNames)
	return strs
}

// IsAHeatPumpMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i HeatPumpMode) IsAHeatPumpMode() bool {
	for _, v := range _HeatPumpModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for HeatPumpMode
func (i HeatPumpMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for HeatPumpMode
func (i *HeatPumpMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("HeatPumpMode should be a string, got %s", data)
	}

	var err error
	*i, err = HeatPumpModeString(s)
	return err
}

const _LockModeName = "OffPartialFull"

var _LockModeIndex = [...]uint8{0, 3, 10, 14}

const _LockModeLowerName = "offpartialfull"

func (i LockMode) String() string {
	if i >= LockMode(len(_LockModeIndex)-1) {
		return fmt.Sprintf("LockMode(%d)", i)
	}
	return _LockModeName[_LockModeIndex[i]:_LockModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LockModeNoOp() {
	var x [1]struct{}
	_ = x[LockModeOff-(0)]
	_ = x[LockModePartial-(1)]
	_ = x[LockModeFull-(2)]
}

var _LockModeValues = []LockMode{LockModeOff, LockModePartial, LockModeFull}

var _LockModeNameToValueMap = map[string]LockMode{
	_LockModeName[0:3]:        LockModeOff,
	_LockModeLowerName[0:3]:   LockModeOff,
	_LockModeName[3:10]:       LockModePartial,
	_LockModeLowerName[3:10]:  LockModePartial,
	_LockModeName[10:14]:      LockModeFull,
	_LockModeLowerName[10:14]: LockModeFull,
}

var _LockModeNames = []string{
	_LockModeName[0:3],
	_LockModeName[3:10],
	_LockModeName[10:14],
}

// LockModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LockModeString(s string) (LockMode, error) {
	if val, ok := _LockModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LockModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LockMode values", s)
}

// LockModeValues returns all values of the enum
func LockModeValues() []LockMode {
	return _LockModeValues
}

// LockModeStrings returns a slice of all String values of the enum
func LockModeStrings() []string {
	strs := make([]string, len(_LockModeNames))
	copy(strs, _LockModeNames)
	return strs
}

// IsALockMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LockMode) IsALockMode() bool {
	for _, v := range _LockModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LockMode
func (i LockMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LockMode
func (i *LockMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LockMode should be a string, got %s", data)
	}

	var err error
	*i, err = LockModeString(s)
	return err
}

const (
	_SleepTimerStateName_0      = "Weekdays"
	_SleepTimerStateLowerName_0 = "weekdays"
	_SleepTimerStateName_1      = "Weekends"
	_SleepTimerStateLowerName_1 = "weekends"
	_SleepTimerStateName_2      = "EverydayOff"
	_SleepTimerStateLowerName_2 = "everydayoff"
)

var (
	_SleepTimerStateIndex_0 = [...]uint8{0, 8}
	_SleepTimerStateIndex_1 = [...]uint8{0, 8}
	_SleepTimerStateIndex_2 = [...]uint8{0, 8, 11}
)

func (i SleepTimerState) String() string {
	switch {
	case i == 31:
		return _SleepTimerStateName_0
	case i == 96:
		return _SleepTimerStateName_1
	case 127 <= i && i <= 128:
		i -= 127
		return _SleepTimerStateName_2[_SleepTimerStateIndex_2[i]:_SleepTimerStateIndex_2[i+1]]
	default:
		return fmt.Sprintf("SleepTimerState(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _SleepTimerStateNoOp() {
	var x [1]struct{}
	_ = x[SleepTimerStateWeekDays-(31)]
	_ = x[SleepTimerStateWeekEnds-(96)]
	_ = x[SleepTimerStateEveryDay-(127)]
	_ = x[SleepTimerStateOff-(128)]
}

var _SleepTimerStateValues = []SleepTimerState{SleepTimerStateWeekDays, SleepTimerStateWeekEnds, SleepTimerStateEveryDay, SleepTimerStateOff}

var _SleepTimerStateNameToValueMap = map[string]SleepTimerState{
	_SleepTimerStateName_0[0:8]:       SleepTimerStateWeekDays,
	_SleepTimerStateLowerName_0[0:8]:  SleepTimerStateWeekDays,
	_SleepTimerStateName_1[0:8]:       SleepTimerStateWeekEnds,
	_SleepTimerStateLowerName_1[0:8]:  SleepTimerStateWeekEnds,
	_SleepTimerStateName_2[0:8]:       SleepTimerStateEveryDay,
	_SleepTimerStateLowerName_2[0:8]:  SleepTimerStateEveryDay,
	_SleepTimerStateName_2[8:11]:      SleepTimerStateOff,
	_SleepTimerStateLowerName_2[8:11]: SleepTimerStateOff,
}

var _SleepTimerStateNames = []string{
	_SleepTimerStateName_0[0:8],
	_SleepTimerStateName_1[0:8],
	_SleepTimerStateName_2[0:8],
	_SleepTimerStateName_2[8:11],
}

// SleepTimerStateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func SleepTimerStateString(s string) (SleepTimerState, error) {
	if val, ok := _SleepTimerStateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _SleepTimerStateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to SleepTimerState values", s)
}

// SleepTimerStateValues returns all values of the enum
func SleepTimerStateValues() []SleepTimerState {
	return _SleepTimerStateValues
}

// SleepTimerStateStrings returns a slice of all String values of the enum
func SleepTimerStateStrings() []string {
	strs := make([]string, len(_SleepTimerStateNames))
	copy(strs, _SleepTimerStateNames)
	return strs
}

// IsASleepTimerState returns "true" if the value is listed in the enum definition. "false" otherwise
func (i SleepTimerState) IsASleepTimerState() bool {
	for _, v := range _SleepTimerStateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for SleepTimerState
func (i SleepTimerState) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for SleepTimerState
func (i *SleepTimerState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("SleepTimerState should be a string, got %s", data)
	}

	var err error
	*i, err = SleepTimerStateString(s)
	return err
}
